//http://www.winprog.org/tutorial/transparency.html
HBITMAP CreateBitmapMask(HDC hdc, HBITMAP hbmColour, COLORREF crTransparent)
{
  HDC hdcMem, hdcMem2;
  HBITMAP hbmMask;
  BITMAP bm;

    // Create monochrome (1 bit) mask bitmap.
  GetObject(hbmColour, sizeof(BITMAP), &bm);
  hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);

    // Get some HDCs that are compatible with the display driver
  hdcMem = CreateCompatibleDC(hdc);
  hdcMem2 = CreateCompatibleDC(hdc);

  SelectObject(hdcMem, hbmColour);
  SelectObject(hdcMem2, hbmMask);

    // Set the background colour of the colour image to the colour
    // you want to be transparent.
  SetBkColor(hdcMem, crTransparent);

    // Copy the bits from the colour image to the B+W mask... everything
    // with the background colour ends up white while everythig else ends up
    // black...Just what we wanted.
  BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem, 0, 0, SRCCOPY);

    // Take our new mask and use it to turn the transparent colour in our
    // original colour image to black so the transparency effect will
    // work right.
  BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem2, 0, 0, SRCINVERT);

    // Clean up.
  DeleteDC(hdcMem);
  DeleteDC(hdcMem2);

  return hbmMask;
}

/*
//https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
HBITMAP GetRotatedBitmap(HBITMAP hBitmap, float radians, COLORREF clrBack )
{
	// Create a memory DC compatible with the display
	HDC sourceDC, destDC;
	sourceDC->CreateCompatibleDC( NULL );
	destDC->CreateCompatibleDC( NULL );

	// Get logical coordinates
	BITMAP bm;
	::GetObject( hBitmap, sizeof( bm ), &bm );

	float cosine = (float)cos(radians);
	float sine = (float)sin(radians);

	// Compute dimensions of the resulting bitmap
	// First get the coordinates of the 3 corners other than origin
	int x1 = (int)(-bm.bmHeight * sine);
	int y1 = (int)(bm.bmHeight * cosine);
	int x2 = (int)(bm.bmWidth * cosine - bm.bmHeight * sine);
	int y2 = (int)(bm.bmHeight * cosine + bm.bmWidth * sine);
	int x3 = (int)(bm.bmWidth * cosine);
	int y3 = (int)(bm.bmWidth * sine);

	int minx = min(0,min(x1, min(x2,x3)));
	int miny = min(0,min(y1, min(y2,y3)));
	int maxx = max(x1, max(x2,x3));
	int maxy = max(y1, max(y2,y3));

	int w = maxx - minx;
	int h = maxy - miny;


	// Create a bitmap to hold the result
	HBITMAP hbmResult = ::CreateCompatibleBitmap(CClientDC(NULL), w, h);

	HBITMAP hbmOldSource = (HBITMAP)::SelectObject( sourceDC.m_hDC, hBitmap );
	HBITMAP hbmOldDest = (HBITMAP)::SelectObject( destDC.m_hDC, hbmResult );

	// Draw the background color before we change mapping mode
	HBRUSH hbrBack = CreateSolidBrush( clrBack );
	HBRUSH hbrOld = (HBRUSH)::SelectObject( destDC.m_hDC, hbrBack );
	destDC.PatBlt( 0, 0, w, h, PATCOPY );
	::DeleteObject( ::SelectObject( destDC.m_hDC, hbrOld ) );

	// Set mapping mode so that +ve y axis is upwords
	sourceDC->SetMapMode(MM_ISOTROPIC);
	sourceDC->SetWindowExt(1,1);
	sourceDC->SetViewportExt(1,-1);
	sourceDC->SetViewportOrg(0, bm.bmHeight-1);

	destDC->SetMapMode(MM_ISOTROPIC);
	destDC->SetWindowExt(1,1);
	destDC->SetViewportExt(1,-1);
	destDC->SetWindowOrg(minx, maxy);

	// Now do the actual rotating - a pixel at a time
	// Computing the destination point for each source point
	// will leave a few pixels that do not get covered
	// So we use a reverse transform - e.i. compute the source point
	// for each destination point

	for( int y = miny; y < maxy; y++ )
	{
		for( int x = minx; x < maxx; x++ )
		{
			int sourcex = (int)(x*cosine + y*sine);
			int sourcey = (int)(y*cosine - x*sine);
			if( sourcex >= 0 && sourcex < bm.bmWidth && sourcey >= 0
					&& sourcey < bm.bmHeight )
				destDC.SetPixel(x,y,sourceDC.GetPixel(sourcex,sourcey));
		}
	}

	// Restore DCs
	::SelectObject( sourceDC.m_hDC, hbmOldSource );
	::SelectObject( destDC.m_hDC, hbmOldDest );

	return hbmResult;
}*/


//https://stackoverflow.com/questions/60922844/hbitmap-stretchblt-caused-image-saturation
HBITMAP ResizeBitmap(HDC hdc, HBITMAP source)
{
    HDC hMemDC1,hMemDC2;

    hMemDC2 = CreateCompatibleDC(hdc);
    HGDIOBJ hOld2 = SelectObject(hMemDC2, source);

    BITMAP bitmap = { 0 };
    GetObject(source, sizeof(BITMAP), &bitmap);

    hMemDC1 = CreateCompatibleDC(hdc);
    HBITMAP hBitmap1 = CreateCompatibleBitmap(hdc, bitmap.bmWidth, bitmap.bmHeight);
    HGDIOBJ hOld1 = SelectObject(hMemDC1, hBitmap1);

   //Flips horizontally (x)
    StretchBlt(hMemDC1, bitmap.bmWidth, 0, -bitmap.bmWidth-1, bitmap.bmHeight, hMemDC2, 0,0, bitmap.bmWidth, bitmap.bmHeight, SRCCOPY);

    SelectObject(hMemDC1, hOld1);
    SelectObject(hMemDC2, hOld2);

    DeleteDC(hMemDC1);
    DeleteDC(hMemDC2);

    return hBitmap1;
}

//https://forums.codeguru.com/showthread.php?118153-Flipping-graphics-using-StretchBlt




/*
https://forum.powerbasic.com/forum/user-to-user-discussions/powerbasic-for-windows/47733-basic-image-rotation-iv-plgblt
Function RotateImage(theta As Single, hSrc As Dword, hDest As Dword) As Long
    Dim PlgPts(0 To 2) As PointAPI
    Local XCenter, YCenter As Long
    XCenter = 149 : YCenter = 149
'   newx = XCenter + (x - XCenter) * Cos(theta) - (y - YCenter) * Sin(theta)
'   newy = YCenter + (x - XCenter) * Sin(theta) + (y - YCenter) * Cos(theta)
    PlgPts(0).X = XCenter + (0   - XCenter) * Cos(theta) - (0   - YCenter) * Sin(theta)  'upper-left in target
    PlgPts(0).Y = YCenter + (0   - XCenter) * Sin(theta) + (0   - YCenter) * Cos(theta)
    PlgPts(1).X = XCenter + (299 - XCenter) * Cos(theta) - (0   - YCenter) * Sin(theta)  'upper-right in target
    PlgPts(1).Y = YCenter + (299 - XCenter) * Sin(theta) + (0   - YCenter) * Cos(theta)
    PlgPts(2).X = XCenter + (0   - XCenter) * Cos(theta) - (299 - YCenter) * Sin(theta)  'lower left in target
    PlgPts(2).Y = YCenter + (0   - XCenter) * Sin(theta) + (299 - YCenter) * Cos(theta)
    PlgBlt(hDest, PlgPts(0), hSrc, 0, 0, 300, 300, 0&, 0, 0)  ' Draw rotated image
End Function
*/




//https://www.codeguru.com/multimedia/rotate-a-bitmap-image/
// GetRotatedBitmap	- Create a new bitmap with rotated image
// Returns		- Returns new bitmap with rotated image
// hBitmap		- Bitmap to rotate
// radians		- Angle of rotation in radians
// clrBack		- Color of pixels in the resulting bitmap that do
//			  not get covered by source pixels
// Note			- If the bitmap uses colors not in the system palette 
//			  then the result is unexpected. You can fix this by
//			  adding an argument for the logical palette.
/*HBITMAP GetRotatedBitmap(HDC hdc, HBITMAP hBitmap, float radians, int COLOR )
{
	// Create a memory DC compatible with the display
	HDC sourceDC, destDC;
	sourceDC=CreateCompatibleDC( hdc );
	destDC=CreateCompatibleDC( hdc );

	// Get logical coordinates
	BITMAP bm;
	GetObject( hBitmap, sizeof( bm ), &bm );

	float cosine = (float)cos(radians);
	float sine = (float)sin(radians);

	// Compute dimensions of the resulting bitmap
	// First get the coordinates of the 3 corners other than origin
	int x1 = (int)(-bm.bmHeight * sine);
	int y1 = (int)(bm.bmHeight * cosine);
	int x2 = (int)(bm.bmWidth * cosine - bm.bmHeight * sine);
	int y2 = (int)(bm.bmHeight * cosine + bm.bmWidth * sine);
	int x3 = (int)(bm.bmWidth * cosine);
	int y3 = (int)(bm.bmWidth * sine);

	int minx = min(0,min(x1, min(x2,x3)));
	int miny = min(0,min(y1, min(y2,y3)));
	int maxx = max(x1, max(x2,x3));
	int maxy = max(y1, max(y2,y3));

	int w = maxx - minx;
	int h = maxy - miny;


	// Create a bitmap to hold the result
	HBITMAP hbmResult = CreateCompatibleBitmap(hdc, w, h);

	HBITMAP hbmOldSource = (HBITMAP) SelectObject( sourceDC, hBitmap );
	HBITMAP hbmOldDest = (HBITMAP)  SelectObject( destDC, hbmResult );

	// Draw the background color before we change mapping mode
	HBRUSH hbrBack = CreateSolidBrush(COLOR);
	HBRUSH hbrOld = (HBRUSH) SelectObject( destDC, hbrBack );
	PatBlt(destDC, 0, 0, w, h, PATCOPY );
	DeleteObject( SelectObject( destDC, hbrOld ) );

	// Set mapping mode so that +ve y axis is upwords
	SetMapMode(sourceDC,MM_ISOTROPIC);
	SetWindowExtEx(sourceDC,1,1,0);
	SetViewportExtEx(sourceDC,1,-1,0);
	SetViewportOrgEx(sourceDC,0, bm.bmHeight-1,0);

	SetMapMode(destDC,MM_ISOTROPIC);
	SetWindowExtEx(destDC,1,1,0);
	SetViewportExtEx(destDC,1,-1,0);
	SetWindowOrgEx(destDC,minx, maxy,0);

	// Now do the actual rotating - a pixel at a time
	// Computing the destination point for each source point
	// will leave a few pixels that do not get covered
	// So we use a reverse transform - e.i. compute the source point
	// for each destination point

	for( int y = miny; y < maxy; y++ ) {
	  for( int x = minx; x < maxx; x++ ) {
		int sourcex = (int)(x*cosine + y*sine);
		int sourcey = (int)(y*cosine - x*sine);
		if(sourcex >= 0 && sourcex < bm.bmWidth && sourcey >= 0 && sourcey < bm.bmHeight)
			SetPixel(destDC,x,y,SetPixel(sourceDC,sourcex,sourcey,COLOR));
	  }
	}

	// Restore DCs
	SelectObject( sourceDC, hbmOldSource );
	SelectObject( destDC, hbmOldDest );

	return hbmResult;
}*/



//https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
HBITMAP Rotate90(HDC hDC, HBITMAP hSourceBitmap)
   {
   HBITMAP hOldSourceBitmap, hOldDestBitmap, hDestBitmap;
   HDC hMemSrc, hMemDest;

   int height, width;
   int i, j;

   BITMAP iSrcBitmap;

   // Step 1: Create a memory DC for the source and destination bitmaps
   //         compatible with the device used.

   hMemSrc = CreateCompatibleDC(hDC);
   hMemDest= CreateCompatibleDC(hDC);

  // Step 2: Get the height and width of the source bitmap.

   GetObject(hSourceBitmap, sizeof(BITMAP), (LPSTR)&iSrcBitmap);
   width = iSrcBitmap.bmWidth;
   height = iSrcBitmap.bmHeight;

   // Step 3: Select the source bitmap into the source DC. Create a
   //         destination bitmap, and select it into the destination DC.

   hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
   hDestBitmap = CreateBitmap(height, width, iSrcBitmap.bmPlanes,
                    iSrcBitmap.bmBitsPixel, NULL);

   if (!hDestBitmap)
     return(hDestBitmap);

   hOldDestBitmap = SelectObject(hMemDest, hDestBitmap);

   // Step 4: Copy the pixels from the source to the destination.

   for (i = 0; i < width; ++i)
       for (j = 0; j < height; ++j)
           SetPixel(hMemDest, j, width - 1 - i,
                                             GetPixel(hMemSrc, i, j));
   // Step 5: Destroy the DCs.

   SelectObject(hMemSrc, hOldSourceBitmap);
   SelectObject(hMemDest, hOldDestBitmap);
   DeleteDC(hMemDest);
   DeleteDC(hMemSrc);

   // Step 6: Return the rotated bitmap.

   return(hDestBitmap);
}





// GetRotatedBitmap	- Create a new bitmap with rotated image
// Returns		- Returns new bitmap with rotated image
// hBitmap		- Bitmap to rotate
// radians		- Angle of rotation in radians
// clrBack		- Color of pixels in the resulting bitmap that do
//			  not get covered by source pixels
// Note			- If the bitmap uses colors not in the system palette 
//			  then the result is unexpected. You can fix this by
//			  adding an argument for the logical palette.
HBITMAP GetRotatedBitmap( HBITMAP hBitmap, float radians, COLORREF clrBack )
{
	// Create a memory DC compatible with the display
	CDC sourceDC, destDC;
	sourceDC.CreateCompatibleDC( NULL );
	destDC.CreateCompatibleDC( NULL );

	// Get logical coordinates
	BITMAP bm;
	::GetObject( hBitmap, sizeof( bm ), &bm );

	float cosine = (float)cos(radians);
	float sine = (float)sin(radians);

	// Compute dimensions of the resulting bitmap
	// First get the coordinates of the 3 corners other than origin
	int x1 = (int)(-bm.bmHeight * sine);
	int y1 = (int)(bm.bmHeight * cosine);
	int x2 = (int)(bm.bmWidth * cosine - bm.bmHeight * sine);
	int y2 = (int)(bm.bmHeight * cosine + bm.bmWidth * sine);
	int x3 = (int)(bm.bmWidth * cosine);
	int y3 = (int)(bm.bmWidth * sine);

	int minx = min(0,min(x1, min(x2,x3)));
	int miny = min(0,min(y1, min(y2,y3)));
	int maxx = max(x1, max(x2,x3));
	int maxy = max(y1, max(y2,y3));

	int w = maxx - minx;
	int h = maxy - miny;


	// Create a bitmap to hold the result
	HBITMAP hbmResult = ::CreateCompatibleBitmap(CClientDC(NULL), w, h);

	HBITMAP hbmOldSource = (HBITMAP)::SelectObject( sourceDC.m_hDC, hBitmap );
	HBITMAP hbmOldDest = (HBITMAP)::SelectObject( destDC.m_hDC, hbmResult );

	// Draw the background color before we change mapping mode
	HBRUSH hbrBack = CreateSolidBrush( clrBack );
	HBRUSH hbrOld = (HBRUSH)::SelectObject( destDC.m_hDC, hbrBack );
	destDC.PatBlt( 0, 0, w, h, PATCOPY );
	::DeleteObject( ::SelectObject( destDC.m_hDC, hbrOld ) );

	// Set mapping mode so that +ve y axis is upwords
	sourceDC.SetMapMode(MM_ISOTROPIC);
	sourceDC.SetWindowExt(1,1);
	sourceDC.SetViewportExt(1,-1);
	sourceDC.SetViewportOrg(0, bm.bmHeight-1);

	destDC.SetMapMode(MM_ISOTROPIC);
	destDC.SetWindowExt(1,1);
	destDC.SetViewportExt(1,-1);
	destDC.SetWindowOrg(minx, maxy);

	// Now do the actual rotating - a pixel at a time
	// Computing the destination point for each source point
	// will leave a few pixels that do not get covered
	// So we use a reverse transform - e.i. compute the source point
	// for each destination point

	for( int y = miny; y < maxy; y++ )
	{
		for( int x = minx; x < maxx; x++ )
		{
			int sourcex = (int)(x*cosine + y*sine);
			int sourcey = (int)(y*cosine - x*sine);
			if( sourcex >= 0 && sourcex < bm.bmWidth && sourcey >= 0
					&& sourcey < bm.bmHeight )
				destDC.SetPixel(x,y,sourceDC.GetPixel(sourcex,sourcey));
		}
	}

	// Restore DCs
	::SelectObject( sourceDC.m_hDC, hbmOldSource );
	::SelectObject( destDC.m_hDC, hbmOldDest );

	return hbmResult;
}





/*
void SetStaticPicture(){
   HBITMAP bmpFrom = (HBITMAP) LoadImage( NULL, "popupbk.bmp", IMAGE_BITMAP, 0, 0,
                      LR_CREATEDIBSECTION | LR_DEFAULTSIZE | LR_LOADFROMFILE );   if( !bmpFrom ) return;
   BITMAP                     bm;
   GetObject( bmpFrom, sizeof(bm), &bm );
   HDC     hdc     = GetDC( hwnd );
   HDC     hdcFrom = CreateCompatibleDC( hdc );
   HDC     hdcTo   = CreateCompatibleDC( hdc );
   HBITMAP bmpTo   = CreateCompatibleBitmap( hdcTo, width, height );
   HGDIOBJ hobFrom = SelectObject( hdcFrom, bmpFrom );
   HGDIOBJ hobTo   = SelectObject( hdcTo, bmpTo );
   StretchBlt( hdcTo,   0, 0, width,      height,               hdcFrom, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );
   SelectObject( hdcFrom, hobFrom );
   SelectObject( hdcTo, hobTo );
   DeleteObject( bmpFrom );
   ReleaseDC( hwnd, hdc );
   DeleteDC( hdcFrom );
   DeleteDC( hdcTo );
   bkgdImage = bmpTo; // <<<< assuming bkgdImage is a HBITMAP member var here
   SendMessage( hwnd, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) bkgdImage );
}*/

//https://www.gamedev.net/forums/topic/583799-win32-load-bitmap-resize-copy-to-static-control/4713803/




//https://ftp.zx.net.nz/pub/Patches/ftp.microsoft.com/MISC/KB/en-us/77/127.HTM
HBITMAP Rotate(HDC hDC, HBITMAP hSourceBitmap, double radians) {
   HBITMAP hOldSourceBitmap, hOldDestBitmap, hDestBitmap;
   HDC hMemSrc, hMemDest;
   BITMAP iSrcBitmap;

   // Step 1: Create a memory DC for the source and destination bitmaps
   //         compatible with the device used.
   hMemSrc = CreateCompatibleDC(hDC);
   hMemDest= CreateCompatibleDC(hDC);

  // Step 2: Get the height and width of the source bitmap.
   GetObject(hSourceBitmap, sizeof(iSrcBitmap), (LPSTR)&iSrcBitmap);

// Get logical coordinates
   double cosine = (double)cos(radians);
   double sine = (double)sin(radians);

	// Compute dimensions of the resulting bitmap
	// First get the coordinates of the 3 corners other than origin
   int x1 = (int)(-iSrcBitmap.bmHeight * sine);
   int y1 = (int)(iSrcBitmap.bmHeight * cosine);
   int x2 = (int)(iSrcBitmap.bmWidth * cosine - iSrcBitmap.bmHeight * sine);
   int y2 = (int)(iSrcBitmap.bmHeight * cosine + iSrcBitmap.bmWidth * sine);
   int x3 = (int)(iSrcBitmap.bmWidth * cosine);
   int y3 = (int)(iSrcBitmap.bmWidth * sine);

   int minx = min(0,min(x1, min(x2,x3)));
   int miny = min(0,min(y1, min(y2,y3)));
   int maxx = max(0,max(x1, max(x2,x3)));
   int maxy = max(0, max(y1, max(y2,y3)));

   int width = maxx - minx;
   int height = maxy - miny;

   // Step 3: Select the source bitmap into the source DC. Create a
   //         destination bitmap, and select it into the destination DC.
   hOldSourceBitmap = SelectObject(hMemSrc, hSourceBitmap);
   //hDestBitmap = CreateBitmap(height, width, iSrcBitmap.bmPlanes, iSrcBitmap.bmBitsPixel, NULL);
   hDestBitmap = CreateCompatibleBitmap(hDC, width, height);   

   if (!hDestBitmap)
     return(hDestBitmap);

   hOldDestBitmap = SelectObject(hMemDest, hDestBitmap);


	// Draw the background color before we change mapping mode
    COLORREF clrBack = RGB(255,255,255); //For transparent background
	HBRUSH hbrBack = CreateSolidBrush( clrBack );
	HBRUSH hbrOld = (HBRUSH) SelectObject( hMemDest, hbrBack );
	PatBlt(hMemDest, 0, 0, width, height, PATCOPY );
	DeleteObject( SelectObject(hMemDest, hbrOld ) );


	// Set mapping mode so that +ve y axis is upwords
	SetMapMode(hMemSrc, MM_ISOTROPIC);
	SetWindowExtEx(hMemSrc, 1,1,NULL);
	SetViewportExtEx(hMemSrc, 1,-1,NULL);
	SetViewportOrgEx(hMemSrc, 0, iSrcBitmap.bmHeight-1,NULL);

	SetMapMode(hMemDest, MM_ISOTROPIC);
	SetWindowExtEx(hMemDest, 1,1,NULL);
	SetViewportExtEx(hMemDest, 1,-1,NULL);
	SetWindowOrgEx(hMemDest, minx, maxy,NULL);



   // Step 4: Copy the pixels from the source to the destination.
   for (int y=miny;y<maxy;y++) {
	 for(int x=minx;x<maxx;x++) {
	   int sourcex = (int)(x*cosine+y*sine);
	   int sourcey = (int)(y*cosine-x*sine);
	   if(sourcex>=0 && sourcex<iSrcBitmap.bmWidth && sourcey>=0
	   	   && sourcey<iSrcBitmap.bmHeight )
	     SetPixel(hMemDest, x, y, GetPixel(hMemSrc,sourcex,sourcey));
	  }
	}

   // Step 5: Destroy the DCs.
   SelectObject(hMemSrc, hOldSourceBitmap);
   SelectObject(hMemDest, hOldDestBitmap);
   DeleteDC(hMemDest);
   DeleteDC(hMemSrc);

   // Step 6: Return the rotated bitmap.
   return(hDestBitmap);
}






bool _Sleep(int msec) {
  current_time=GetTickCount();
  long long time_diff=current_time-saved_time;
  if (time_diff>=msec) { //if timediff is above 6 millisecs,
    saved_time=current_time; 
    return true;
  }
  //if timediff is less than 6 millisecs
  //Sleep(1);
  YieldProcessor();
  return false;
}

void delay(unsigned int mseconds)
{
    clock_t goal = mseconds + clock();
    while (goal > clock())
      YieldProcessor();
}


//https://learn.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps?redirectedfrom=MSDN
/*
LARGE_INTEGER StartingTime, EndingTime, ElapsedMicroseconds;
LARGE_INTEGER Frequency;

QueryPerformanceFrequency(&Frequency); 
QueryPerformanceCounter(&StartingTime);

// Activity to be timed
//for (int t=0;t<65536;t++);
PlayerAct();
delay(1);

QueryPerformanceCounter(&EndingTime);
ElapsedMicroseconds.QuadPart = EndingTime.QuadPart - StartingTime.QuadPart;

ElapsedMicroseconds.QuadPart *= 1000000;
ElapsedMicroseconds.QuadPart /= Frequency.QuadPart;
printf("EMS: %d\n",ElapsedMicroseconds.QuadPart);*/

//https://learncgames.com/using-small-delays-in-c-with-sdl-ticks/







/*int machinespeed() {
  struct timeval time_start,time_now;
  int tick,i,j,c=2048,d=5;
  double sum=0,sum2=0;
  for (j=0;j<d;j++) { //5 times & generate avg
    for (i=0;i<c;i++) { //count to 65546 2048 times & generate avg
      mingw_gettimeofday(&time_start, NULL); //get time in msec
      for (tick=0;tick<65536;tick++);
      mingw_gettimeofday(&time_now, NULL); //get time in msec after for count
      sum += (time_now.tv_sec - time_start.tv_sec) * 1000000 + time_now.tv_usec - time_start.tv_usec;
    }
    sum2+=sum/c;
    sum=0;
  }
  return (int) sum2/d; //return machine speed
}*/

/*int machinespeed() {
  int tick=0;
  long long start_time=current_timestamp();
  long long current_time=LLONG_MAX;

  long long time_diff;
  while (true) {
    time_diff=current_time-start_time;
    if (time_diff<100) {
      current_time=current_timestamp();
      tick++;
    } else {
      return tick/100;
    }
  }
}*/




HBITMAP CreateBitmapMask(HBITMAP hbmColour, COLORREF crTransparent)
{
    HDC hdcMem, hdcMem2;
    HBITMAP hbmMask;
    BITMAP bm;

    // Create monochrome (1 bit) mask bitmap.  

    GetObject(hbmColour, sizeof(BITMAP), &bm);
    hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);

    // Get some HDCs that are compatible with the display driver

    hdcMem = CreateCompatibleDC(0);
    hdcMem2 = CreateCompatibleDC(0);

    SelectBitmap(hdcMem, hbmColour);
    SelectBitmap(hdcMem2, hbmMask);

    // Set the background colour of the colour image to the colour
    // you want to be transparent.
    SetBkColor(hdcMem, crTransparent);

    // Copy the bits from the colour image to the B+W mask... everything
    // with the background colour ends up white while everythig else ends up
    // black...Just what we wanted.

    BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem, 0, 0, SRCCOPY);

    // Take our new mask and use it to turn the transparent colour in our
    // original colour image to black so the transparency effect will
    // work right.
    BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem2, 0, 0, SRCINVERT);

    // Clean up.

    DeleteDC(hdcMem);
    DeleteDC(hdcMem2);

    return hbmMask;
}












/*void DrawTriFill(HWND hwnd, HDC hdc, PAINTSTRUCT ps,int tri_color,double x1,double y1,double x2,double y2,double x3,double y3)
{
  double x_1,x_2,
      gradient_middle1,gradient_middle2,gradient_largest,
      c_middle1,c_middle2,c_largest,
      smallest=9999,largest=0,
      x_arr[3],y_arr[3];
  x_arr[0]=x1;
  x_arr[1]=x2;
  x_arr[2]=x3;
  y_arr[0]=y1;
  y_arr[1]=y2;
  y_arr[2]=y3;
  int i,saved_largest=0,saved_smallest=0,saved_middle=0;
  for (i=0;i<3;i++) {
    if (y_arr[i]<smallest) {
      smallest=y_arr[i];
      saved_smallest=i;
    }
  }
  for (i=0;i<3;i++) {
    if (y_arr[i]>largest) {
      largest=y_arr[i];
      saved_largest=i;
    }
  }
  for (i=0;i<3;i++) {
    if (i!=saved_smallest && i!=saved_largest) {
      saved_middle=i;
    }
  }
  gradient_middle1=GetGradient(x_arr[saved_smallest],y_arr[saved_smallest],x_arr[saved_middle],y_arr[saved_middle]); //Gradient of main line
  c_middle1=GetGroundC(x_arr[saved_smallest],y_arr[saved_smallest],gradient_middle1);

  gradient_middle2=GetGradient(x_arr[saved_largest],y_arr[saved_largest],x_arr[saved_middle],y_arr[saved_middle]);
  c_middle2=GetGroundC(x_arr[saved_largest],y_arr[saved_largest],gradient_middle2);

  gradient_largest=GetGradient(x_arr[saved_largest],y_arr[saved_largest],x_arr[saved_smallest],y_arr[saved_smallest]);
  c_largest=GetGroundC(x_arr[saved_smallest],y_arr[saved_smallest],gradient_largest);
  for (i=smallest;i<y_arr[saved_middle];i+=1) {//small to middle
    x_1=GetX(i,gradient_middle1,c_middle1);
    x_2=GetX(i,gradient_largest,c_largest);
    GrLine(hwnd,hdc,ps,x_1,i,x_2,i,tri_color);
  }
  for (i=y_arr[saved_middle];i<largest;i+=1) {//middle to largest
    x_1=GetX(i,gradient_middle2,c_middle2);
    x_2=GetX(i,gradient_largest,c_largest);
    GrLine(hwnd,hdc,ps,x_1,i,x_2,i,tri_color);
  }
}*/


























        /*player.valid_web=FALSE;
        pivot_node_grid_id=GetGridId(player.above_x,player.above_y,MAP_WIDTH,NODE_SIZE,MAP_NODE_NUM);
        pivot_x=NodeGrid[pivot_node_grid_id].x1+NODE_SIZE/2;
        pivot_y=NodeGrid[pivot_node_grid_id].y1+NODE_SIZE/2;
        edge_x=NodeGrid[edge_node_grid_id].x1+NODE_SIZE/2;
        edge_y=NodeGrid[edge_node_grid_id].y1+NODE_SIZE/2;
        if (pivot_x<edge_x) {
          bm_x1=pivot_x;
          bm_y1=pivot_y;
          bm_x2=edge_x;
          bm_y2=edge_y;
        } else {
          bm_x1=edge_x;
          bm_y1=edge_y;
          bm_x2=pivot_x;
          bm_y2=pivot_y;
        }
        bm_gradient=GetGradient(bm_x1,bm_y1,bm_x2,bm_y2);
        allow_act=FALSE;
        if (player.bullet_shot==-1) {
          if (GetDistance(pivot_x,pivot_y,edge_x,edge_y)<=DEFAULT_PLAYER_SHORT_BUILD_RANGE*NODE_SIZE
	    && !IsCollideSolid(bm_x1,bm_y1,bm_x2,bm_y2,bm_gradient,GetGroundC(bm_x1,bm_y1,bm_gradient))
	        ) {
	        if (!IsCollideCrawler(bm_x1,bm_y1,bm_x2,bm_y2,bm_gradient,GetGroundC(bm_x1,bm_y1,bm_gradient))
              && pivot_x!=edge_x) {
	          allow_act=TRUE;
	        }
	      }
        }
      //^^ condition
        if (allow_act) {
          player.valid_web=
    	  player.print_valid_web=TRUE;
        } else {
    	  player.print_valid_web=FALSE;
        }    
        allow_act=FALSE;
        if (player.on_ground_id!=-1 && player.placed_web_num<player.max_web_num) {
    	  allow_act=TRUE;
        }
        if (player.right_click_hold_timer==62 && allow_act) {//Right click to shoot
          if (player.valid_web) {//place web
            player.attack=TRUE;
    	    player.valid_web=FALSE;
            if (player.placed_web_pos<player.max_web_num) {      
              while (player.web_storage[player.placed_web_pos]==-1) {
                player.placed_web_pos=LimitValue(player.placed_web_pos+1,0,player.max_web_num);
              }
              web_id=player.web_storage[player.placed_web_pos];
              if (web_id!=-1) {
                Ground[web_id].x1=bm_x1;
                Ground[web_id].y1=bm_y1;
                Ground[web_id].x2=bm_x2;
                Ground[web_id].y2=bm_y2;
                SetGround(web_id);
                SetNodeGridAttributes(web_id);
    	        Ground[web_id].health=5;
                player.web_storage[player.placed_web_pos]=-1;
                player.placed_web_pos++;
    	        player.placed_web_num++;
    	     }
	         if (player.placed_web_pos>=player.max_web_num) {
	           player.placed_web_pos=0;
	         }
           }
         }
       }*/






















      //=====JUST A DEMO=====
      //Load Player cache Sprites
      /*SetRotatedSpriteSize(
        NULL,
        player.sprite_1,
        0,
        &player.sprite_minx,
        &player.sprite_miny,
        &player.sprite_maxx,
        &player.sprite_maxy,
        &player.sprite_width,
        &player.sprite_height
      );*/



      /*unsigned char* lpBitmapBits2; 

      BITMAPINFO bi2; 
      ZeroMemory(&bi2, sizeof(BITMAPINFO));
      bi2.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
      bi2.bmiHeader.biWidth=player.sprite_width;
      bi2.bmiHeader.biHeight=-player.sprite_height;
      bi2.bmiHeader.biPlanes=1;
      bi2.bmiHeader.biBitCount=32;

      player.sprite_jump_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);
      player.sprite_1_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);
      player.sprite_2_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);

      player.attack_sprite_1_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);
      player.attack_sprite_2_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);
      player.attack_sprite_3_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);
      player.attack_sprite_4_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);

      player.block_sprite_1_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);
      player.block_sprite_2_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);
      player.block_sprite_3_cache=CreateDIBSection(NULL,&bi2,DIB_RGB_COLORS, (VOID**)&lpBitmapBits2,NULL,0);*/

      //printf("new sizes:%d %d\n",player.sprite_width,player.sprite_height);
      /*player.current_draw_row=-1;
      for (int a=player.sprite_miny;a<player.sprite_maxy;a++) {
        RotateSpriteII(NULL, player.sprite_jump, player.sprite_jump_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 
        RotateSpriteII(NULL, player.sprite_1, player.sprite_1_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 
        RotateSpriteII(NULL, player.sprite_2, player.sprite_2_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 

        RotateSpriteII(NULL, player.attack_sprite_1, player.attack_sprite_1_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 
        RotateSpriteII(NULL, player.attack_sprite_2, player.attack_sprite_2_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 
        RotateSpriteII(NULL, player.attack_sprite_3, player.attack_sprite_3_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 
        RotateSpriteII(NULL, player.attack_sprite_4, player.attack_sprite_4_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 

        RotateSpriteII(NULL, player.block_sprite_1, player.block_sprite_1_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 
        RotateSpriteII(NULL, player.block_sprite_2, player.block_sprite_2_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 
        RotateSpriteII(NULL, player.block_sprite_3, player.block_sprite_3_cache,0, LTGREEN, BLACK, -1, player.sprite_minx, player.sprite_miny, player.sprite_maxx, player.sprite_maxy, a); 
      }*/













  /*char txt3[10];
  int print_1=frame_tick;
  sprintf(txt3,"%d",print_1);  
  GrPrint(hdc,0,32,txt3,c);*/

  /*char txt3[10];
  int print_1=player.time_breaker_recharge_timer;
  sprintf(txt3,"%d",print_1);  
  GrPrint(hdc,0,32,txt3,c);


  char txt4[10];
  int print_2= player.time_breaker_cooldown;
  sprintf(txt4,"%d",print_2);  
  GrPrint(hdc,0,48,txt4,c);


  char txt5[10];
  int print_3=player.time_breaker_units;
  sprintf(txt5,"%d",print_3);  
  GrPrint(hdc,0,64,txt5,c);*/







  /*for (int i=player.block_health;i>0;i--) {
    GrCircle(hdc,player.sprite_x+8*i,player.sprite_y+32,2,LTGRAY,LTGRAY);
  }*/

  //Print Player Block Health
  //int print_block_health=player.block_health;
  //sprintf(txt,"%d",print_block_health);
  //GrPrint(hDC,mouse_x,mouse_y+32,txt, BLACK);


/*  char txt3[19];
  int print_dynrenderdist=dyn_vrenderdist;
  sprintf(txt3,"Render Distance: %d",print_dynrenderdist);  
  GrPrint(hdc,0,32,txt3,c);


  char txt4[10];
  int print_left = player.previous_web_placed;
  int print_left2= player.on_ground_id;
  sprintf(txt4,"%d webplaced: %d",print_left2, print_left);  
  GrPrint(hdc,0,48,txt4,c);*/


  /*char txt5[10];
  int print_speed=player.speed;
  int print_grav_speed=player.grav;
  sprintf(txt5,"Speed:%d  %d",print_grav_speed, print_speed);  
  GrPrint(hdc,0,64,txt5,c);*/
  //GrPrint(hwnd,hdc,ps,0,16,_txt2,RGB(RandNum(0,255),RandNum(0,255),RandNum(0,255)));


  /*char txt6[16];
  int print_jump=player.in_air_timer;
  sprintf(txt6,"inairtimer: %d",print_jump);  
  GrPrint(hdc,0,80,txt6,c);*/



/*struct custard
{
  int cream;
};

int amount=10;
struct custard* Custard;*/

/*void InitCustard()
{
  /*Custard=(struct custard*)malloc(amount*sizeof(struct custard));
  for (int du=0;du<amount;du++) {
    Custard[du].cream=du*2;
  }*/
  /*for (int du=0;du<amount;du++) {
    printf("%d",Custard[du].cream);
  }*/
  /*free(Custard);
  Custard=NULL;
}*/

/*int* ptr;

void initdum()
{
  ptr=(int*)malloc(size*sizeof(int));
  for (int du=0;du<size;du++) {
    ptr[du]=du*2;
  }
  for (int du=0;du<size;du++) {
    printf("%d",ptr[du]);
  }
}*/

//struct Custard Custards[size];

/*int palette_dark_arr[COLORS_NUM]={
BLACK,
BLUE,
GREEN,
CYAN,
RED,
PURPLE,
BROWN,
LTGRAY,
DKGRAY,
LTBLUE,
LTGREEN,
LTCYAN,
LTRED,
LTPURPLE,
YELLOW,
WHITE
};*/




